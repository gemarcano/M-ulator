//*******************************************************************************************
// XT1 (TMCv2r1) FIRMWARE
// Version 3.01a (devel)
//------------------------
#define HARDWARE_ID 0x01005843  // XT1r1 Hardware ID
#define FIRMWARE_ID 0x0301      // [15:8] Integer part, [7:0]: Non-Integer part
//-------------------------------------------------------------------------------------------
// < UPDATE HISTORY >
//  Jan 05 2023 - Version 3.00
//                  - Hard-forked & modified from xt1_firmware_v2p10
//  See Google Doc for detailed update history.
//-------------------------------------------------------------------------------------------
//
// External Connections
//
//  XT1r1       NFC (ST25DVxxx)     XT1     e-Ink Display           Display    
//  ---------------------------     ------------------------                       
//  GPIO[0]     GPO                 SEG[0]  Play                       [==]                 .
//  GPIO[1]     SCL                 SEG[1]  Tick                                            .
//  GPIO[2]     Not Used            SEG[2]  Low Battery               \\  //                .
//  GPIO[3]     SDA                 SEG[3]  Back Slash          |\     \\//    +            .
//  VPG2_OUT    VCC                 SEG[4]  Slash               |/     //\\    -            .
//                                  SEG[5]  Plus                    \\//  \\                .
//                                  SEG[6]  Minus                                
//
//-------------------------------------------------------------------------------------------
// SNT Temperature Sensor
//-------------------------------------------------------------------------------------------
//
//  Temperature Range: -40C ~ +65C (FP Specification)
//
//-------------------------------------------------------------------------------------------
// Use of Cortex-M0 Vector Table
//  ----------------------------------------------------------
//   MEM_ADDR  M0-Usage       PRE-Usage       PRE-Usage       
//                            (GPIO)          (AES)           
//  ----------------------------------------------------------
//    0 (0x00) STACK_TOP      STACK_TOP       STACK_TOP       
//    1 (0x04) RESET_VECTOR   RESET_VECTOR    RESET_VECTOR    
//    2 (0x08) NMI            GOC_DATA_IRQ    GOC_DATA_IRQ    
//    3 (0x0C) HardFault                      GOC_AES_PASS    
//    4 (0x10) RESERVED                       GOC_AES_CT[0]   
//    5 (0x14) RESERVED                       GOC_AES_CT[1]   
//    6 (0x18) RESERVED                       GOC_AES_CT[2]   
//    7 (0x1C) RESERVED                       GOC_AES_CT[3]   
//    8 (0x20) RESERVED                       GOC_AES_PT[0]   
//    9 (0x24) RESERVED                       GOC_AES_PT[1]   
//   10 (0x28) RESERVED                       GOC_AES_PT[2]   
//   11 (0x2C) SVCall                         GOC_AES_PT[3]   
//   12 (0x30) RESERVED                       GOC_AES_KEY[0]  
//   13 (0x34) RESERVED       R_GPIO_DATA     GOC_AES_KEY[1]  
//   14 (0x38) PendSV         R_GPIO_DIR      GOC_AES_KEY[2]  
//   15 (0x3C) SysTick        R_GPIO_IRQ_MASK GOC_AES_KEY[3]  
//
//-------------------------------------------------------------------------------------------
// WAKEUP_SOURCE (wakeup_source) definition
//-------------------------------------------------------------------------------------------
//
//  Use get_bit(wakeup_source, n) to get the current value, where n is 0-5, 8-11 as shown below.
//
//  [31:12] - Reserved
//     [11] - GPIO_PAD[3] has triggered wakeup (valid only when wakeup_source[3]=1)
//     [10] - GPIO_PAD[2] has triggered wakeup (valid only when wakeup_source[3]=1)
//     [ 9] - GPIO_PAD[1] has triggered wakeup (valid only when wakeup_source[3]=1)
//     [ 8] - GPIO_PAD[0] has triggered wakeup (valid only when wakeup_source[3]=1)
//      [7] - Reserved (NOTE: wakeup_source[7] is used to indicate that the previous 'sleep' has been skipped)
//      [6] - Reserved
//      [5] - GIT (GOC Instant Trigger) has triggered wakeup
//              NOTE: If GIT is triggered while the system is in active, the GIT is NOT immediately handled.
//                    Instead, it waits until the system goes in sleep, and then, the (pending) GIT will wake up the system.
//                    Thus, you can safely assume that GIT is (effectively) triggered only while the system is in Sleep.
//      [4] - MBus message has triggered wakeup (e.g., Flash Auto Boot-up)
//      [3] - One of GPIO_PAD[3:0] has triggered wakeup
//      [2] - XO Timer has triggered wakeup
//      [1] - Wake-up Timer has triggered wakeup
//      [0] - GOC/EP has triggered wakeup
//
//-------------------------------------------------------------------------------------------
// DEBUG Messages
//-------------------------------------------------------------------------------------------
// Valid only when DEVEL is enabled
//
//  ADDR    DATA                                Description
//  -----------------------------------------------------------------------------------------
//
//  -----------------------------------------------------------------------------------------
//  < FSM >
//  -----------------------------------------------------------------------------------------
//  0x70    wakeup_source                       Wakeup Source (See above WAKEUP_SOURCE definition)
//                                                  0x0001: GOC/EP
//                                                  0x0002: PRE Wakeup Timer
//                                                  0x0010: SNT Timer (MBus)
//                                                  0x0108: NFC (GPIO[0])
//  0x71    xt1_state                           XT1 State (See set_system() below)
//  0x72    target                              set_system() is called for target:
//                                                  0x0: XT1_RESET       
//                                                  0x1: XT1_IDLE        
//                                                  0x2: XT1_PEND        
//                                                  0x3: XT1_ACTIVE      
//                                                  0x9: XT1_CRASH       
//  0x73    value                               Function Calls
//                                                  0x0: reset_system_status() is called
//                                                  0x1: update_system_configs() is called and uses the default values
//                                                  0x2: update_system_configs() is called and uses the values read from EEPROM
//                                                  0x3: update_user_configs() is called
//                                                  0x5: update_aes_key() is called
//                                                  0xF: debug_system_configs() is called
//  0x74    value                               Temperature Thresholds (given by user)
//                                                  [31:16] Low Threshold
//                                                  [15: 0] High Threshold
//  0x75    value                               Measurement Configuration
//                                                  [31:16] Start Delay (unit: minutes)
//                                                  [15: 0] Measurement Interval (unit: minutes)
//  0x76    value                               Temperature Calibration Coefficient A gets updated to 'value'
//  0x77    value                               Temperature Calibration Coefficient B gets updated to 'value'
//  0x78    value                               aes_key[0] is set to 'value'
//  0x79    value                               aes_key[1] is set to 'value'
//  0x7A    value                               aes_key[2] is set to 'value'
//  0x7B    value                               aes_key[3] is set to 'value'
//  0x7C    value                               Measurement Configuration
//                                                  [15: 0] num_cons_excursions
//  0x7F    value                               FSM Information
//                                                  0x1: snt_read_wup_timer() - snt_threshold is too large. Going into sleep. // FIXME: Remove this from the parser.
//                                                  0x2: GPO pulse detected before/during low-power active mode // FIXME: Remove this from the parser..
//
//  -----------------------------------------------------------------------------------------
//  < XO and SNT Timer - calibrate_snt_timer() >
//  -----------------------------------------------------------------------------------------
//  0x80    xo_val_prev                         Previous session's XO value (xo_val_prev)
//  0x81    xo_val_curr                         Current session's XO value (xo_val_curr)
//  0x82    temp_xo_val                         Latest XO value (temp_xo_val)
//  0x83    value                               Calibration Status
//                                                  0x0: XO has failed before. Will not perform the calibration in this session.
//                                                  0x1: XO was unstable while reading temp_xo_val
//                                                  0x2: XO counter has not incremented (i.e., temp_xo_val <= xo_val_curr)
//                                                  0x3: 'skip_calib' or 'MAIN_CALLED' or 'FLAG_INVLD_XO_PREV' is 1. Will use the previous snt_freq as it is.
//                                                  0x4: Beginning the calibration
//                                                  0x5: Calculated a is not close to 1 (allowed error: 25%)
//                                                  0x6: Calibration has failed. Will restart the XO.
//                                                  0x7: Calibration is done and successful
//                                                  0x8: Skipping the snt_threshold calculation (usually due to a new START/STOP/RESET command)
//                                                  0x9: Calculated snt_threshold was 0, so it is forced to 1.
//                                                  0xA: main() has been directly called, i.e., Sleep has been bypassed before the current active session. 
//                                                          This implies that xo_val_curr is inaccurate.
//                                                          It uses the previous snt_freq to calculate the next snt_threshold.
//                                                  0xB: FLAG_INVLD_XO_PREV is 1. i.e., XO was restarted during the previous wakeup -OR- Sleep has been bypassed before the previous active session.
//                                                          This implies that xo_val_prev is inaccurate.
//                                                          It uses the previous snt_freq to calculate the next snt_threshold.
//  0x84    snt_duration                        SNT counter value that corresponds to the given interval (previous sleep duration)
//  0x85    XO_FREQ                             XO frequency
//  0x86    snt_freq                            SNT frequency that is used for the previous sleep.
//  0x87    delta_xo_val                        xo_val_curr - xo_val_prev
//  0x88    a                                   Calculated a (Custom fixed-point, N=30)
//  0x89    temp_snt_freq                       Newly Calculated SNT frequency
//  0x8A    wakeup_interval_sec                 New wakeup interval (in seconds)
//  0x8B    snt_duration                        Newly calculated snt_duration
//  0x8C    snt_threshold                       Newly calculated snt_threshold
//  0x8D    snt_threshold_prev                  Previous snt_threshold
//  0x8E    snt_threshold                       snt_threshold
//  0x8F    snt_threshold                       Going into sleep with snt_threshold
//  
//  -----------------------------------------------------------------------------------------
//  < Temperature Measurement >
//  -----------------------------------------------------------------------------------------
//  0x90    value                               Measured Temperature
//                                                  [31:16] Raw code (*SNT_TARGET_REG_ADDR)
//                                                  [15: 0] After the conversion (temp.val) "10 x (T + 80)" where T is the actual temperature in celsius degree.
//  0x91    0x00000000                          meas_temp_adc() is called with go_sleep=0 // FIXME: Add to the parser
//  0x91    0x00000001                          meas_temp_adc() is called with go_sleep=1 // FIXME: Add to the parser
//  0x91    0x00000002                          meas_temp_adc() is called with go_sleep=1 & FLAG_TEMP_MEAS_PEND=0 // FIXME: Add to the parser
//  0x91    0x00000003                          meas_temp_adc() is called with go_sleep=1 & FLAG_TEMP_MEAS_PEND=1 // FIXME: Add to the parser
//  0x91    0xFFFFFFFF                          Skipped the temperature measurement since meas.valid=1
//  0x92    {0x1, sub_sample_cnt}               Sub-sample count
//  0x92    {0x2, sub_sample_sum}               Current sum of the sub-samples
//  0x92    {0x3, temp_sample_cnt}              Temp sample count (NOTE: Temp Sample ID = temp_sample_cnt - 1)
//  0x93    value                               VBAT and SAR Ratio Information
//                                                  [   28] Critical VBAT (crit_vbat)
//                                                  [   24] Low VBAT (low_vbat)
//                                                  [23:16] ADC Offset (adc_offset)
//                                                  [15: 8] SAR Ratio (meas.sar)
//                                                  [ 7: 0] ADC Reading (meas.adc)
//  0x94    value                               PMU SAR Ratio is changing
//                                                  [15: 8] Previous SAR Ratio
//                                                  [ 7: 0] New SAR Ratio
//  0x95    value                               Temperature Data read from the write buffer
//                                                  [15: 0] Temperature Data read from the write buffer (temp.val)
//  0x96    comp_sample_id                      Compression Sample ID
//  0x97    value                               (Reversed) Raw/Encoded data to be stored
//                                                  [31:24] Number of bits
//                                                  [23: 0] Reversed code
//  0x9A    value                               [DEPRECATED] Measured Temperature (from snt_get_temp_raw())
//                                                  [15: 0] Raw code (*SNT_TARGET_REG_ADDR)
//  0x9B    value                               [DEPRECATED] Measured Temperature (from snt_get_temp())
//                                                  [15: 0] After the conversion (temp.val) "10 x (T + 80)" where T is the actual temperature in celsius degree.
//  0x9C    value                               Averaged sample value
//  0x9D    {0x00, tmp_exc.num_cons_hi}         temp.val exceeds the high threshold. Alarm not yet triggered.
//  0x9D    {0x0F, tmp_exc.num_cons_hi}         temp.val exceeds the high threshold. A new alarm has been triggered.
//  0x9D    {0x10, tmp_exc.num_cons_lo}         temp.val exceeds the low threshold. Alarm not yet triggered.
//  0x9D    {0x1F, tmp_exc.num_cons_lo}         temp.val exceeds the low threshold. A new alarm has been triggered.
//  0x9E    value                               Current alarm status
//                                                  0xFFFFFFFF: High Alarm && Low Alarm
//                                                  0xFFFF0000: High Alarm Only
//                                                  0x0000FFFF: Low Alarm && Low Alarm
//                                                  0x00000000: No Alarm
//
//  <--- Below are valid only when [Raw Sample] is enabled --->
//
//  0x9C    byte_addr                           [Raw Sample] Byte Address
//  0x9D    temp.val                            [Raw Sample] Raw Temperature Data
//  0x9E    sar_adc_addr                        [Raw Sample] Byte Address to store SAR/ADC (or XO FAIL) value
//  0x9F    sar_adc_data                        [Raw Sample] SAR/ADC (or XO FAIL) data
//
//  -----------------------------------------------------------------------------------------
//  < Display >
//  -----------------------------------------------------------------------------------------
//  0xA0    {0x0, pattern}                      Display has changed to 'pattern' (EEPROM Updated)
//  0xA0    {0x1, pattern}                      Display has been refreshed with 'pattern' (EEPROM Not Updated)
//  0xA0    {0x2, pattern}                      Display has changed to 'pattern' but failed to update the EEPROM.
//  0xA0    {0xF, pattern}                      Display has blinked.
//  0xA1    disp_min_since_refresh              Elapsed time (in minutes) since the last E-ink update
//  0xA2    value                               EID duration and Refresh Interval are set
//                                                  [31:16] EID Duration
//                                                  [15: 0] Refresh Interval (minutes)
//  0xA3    0x00000000                          Critical Temperature. Display did not update, although XT1 behaves like it did.
//  0xA4    0x00000001                          [DEPRECATED] eid_update_display() requires a new temperature measurement
//  0xA5    eid_updated_at_low_temp             1 indicates that the display has been updated at a low temperature
//  0xA6    eid_updated_at_crit_temp            1 indicates that the display has a pending update due to a critical temperature
//  0xA7    eid_update_type                     Update type used for the display update
//                                                  0x0: Global Update
//                                                  0x1: Local Update
//  0xA8    0x00000000                          display_low_batt() is called.
//  0xA8    0xFFFFFFFF                          Does not have to display LOW_BATT since it is already on.
//
//  -----------------------------------------------------------------------------------------
//  < NFC and EEPROM >
//  -----------------------------------------------------------------------------------------
//  0xB0    target                              The returned 'target' value from nfc_check_cmd()
//  0xB1    value                               NFC Command Info
//                                                  [23:16]: Command Parameter (cmd_param)
//                                                  [ 4: 0]: Command
//                                                              0x00: NOP         
//                                                              0x01: START       
//                                                              0x02: STOP        
//                                                              0x03: GETSEC        
//                                                              0x04: CONFIG
//                                                              0x07: HRESET      
//                                                              0x08: NEWKEY      
//                                                              0x09: NEWAB
//                                                              0x10: DISPLAY     
//                                                              0x1E: SRESET       
//                                                              0x1F: DEBUG       
//  0xB2    value                               ACK with Data Successful and 'value' is written in EEPROM_ADDR_CMD
//  0xB3    value                               ACK with Data Fail; 'value' was supposed to be written in EEPROM_ADDR_CMD
//
//  --- buffer_update()
//  0xB4    data                                Unencrypted data (qword)
//  0xB5    addr                                buffer_eeprom_addr
//  0xB6    data                                Encrypted data
//  0xB7    CRC                                 buffer_crc32
//
//  --- buffer_commit()
//  0xB8    value                               buffer_commit() result
//                                                  0x1: Successfully committed the buffer
//                                                  0x0: There was no data in the buffer
//
//  --- status
