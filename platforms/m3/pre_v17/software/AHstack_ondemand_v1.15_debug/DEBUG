<Both>
wakeup_data_header == 0x32,
wakeup_data[21] = 1 // SHT35
wakeup_data[20] = 1 // ADXL

-> sleep current = ~380nA

<Stop>
wakeup_data_header = 0x33

-> sleep current = ~180nA

<SHT Only>
wakeup_data_header == 0x32,
wakeup_data[21] = 1 // SHT35
wakeup_data[20] = 0 // ADXL

-> sleep current = ~30nA


1780:   int main(){
1812:   pmu_adc_read_latest();
1955:   if (astack_detection_mode & 0x1) ADXL362_enable();
283:        operation_spi_init();
336:            gpio_set_dir_with_mask(adxl_mask,(1<<GPIO_ADXL_EN) | (0<<GPIO_ADXL_INT));
337:            gpio_write_data_with_mask(adxl_mask,(1<<GPIO_ADXL_EN) | (0<<GPIO_ADXL_INT)); // << Crashes here
338:            unfreeze_gpio_out();
339:            unfreeze_spi_out();
287:        *REG_CPS = *REG_CPS | 0x2;      // Turn on ADXL
291:        ADXL362_init();
251:            ADXL362_reg_wr(ADXL362_SOFT_RESET,0x52);
227:                gpio_write_data_with_mask(adxl_mask,(0<<GPIO_ADXL_EN) | (0<<GPIO_ADXL_INT));
233:                gpio_write_data_with_mask(adxl_mask,(1<<GPIO_ADXL_EN) | (0<<GPIO_ADXL_INT));
275:            ADXL362_reg_rd(ADXL362_STATUS);
238:                gpio_write_data_with_mask(adxl_mask,(0<<GPIO_ADXL_EN) | (0<<GPIO_ADXL_INT));
244:                gpio_write_data_with_mask(adxl_mask,(1<<GPIO_ADXL_EN) | (0<<GPIO_ADXL_INT));
294         operation_spi_stop();
343:            freeze_spi_out();
344:            freeze_gpio_out();
1974:   operation_sns_run();

1549:       sht35_meas_data();
535:            *REG_CPS = *REG_CPS | 0x1;      // Turn on SHT
538:            operation_i2c_start();
353:                gpio_write_data_with_mask(sht35_mask,(1<<GPIO_SDA) | (1<<GPIO_SCL));
355:                gpio_set_dir_with_mask(sht35_mask,(1<<GPIO_SDA) | (1<<GPIO_SCL));
356:                unfreeze_gpio_out();    // No freeze following?
542:            operation_i2c_stop();   
560:            *REG_CPS = *REG_CPS & 0xFFFFFFFE;   // Turn off SHT

1653:       ADXL362_power_off();
323:            ADXL362_stop();
301:                operation_spi_init();
336:                    gpio_set_dir_with_mask(adxl_mask,(1<<GPIO_ADXL_EN) | (0<<GPIO_ADXL_INT));
337:                    gpio_write_data_with_mask(adxl_mask,(1<<GPIO_ADXL_EN) | (0<<GPIO_ADXL_INT)); // << Crashes here
338:                    unfreeze_gpio_out();
339:                    unfreeze_spi_out();
310:                operation_spi_stop();
343:                    freeze_spi_out();
344:                    freeze_gpio_out();
314:                unfreeze_gpio_out();                // ????
316:                gpio_set_dir_with_mask(adxl_mask,(1<<GPIO_ADXL_EN) | (1<<GPIO_ADXL_INT));
317:                gpio_write_data_with_mask(adxl_mask,0);
318:                freeze_gpio_out();
325:            *REG_CPS = *REG_CPS & 0xFFFFFFFD;   // Turn off ADXL
1658:       ADXL362_enable();
283:            operation_spi_init();
336:                gpio_set_dir_with_mask(adxl_mask,(1<<GPIO_ADXL_EN) | (0<<GPIO_ADXL_INT));
337:                gpio_write_data_with_mask(adxl_mask,(1<<GPIO_ADXL_EN) | (0<<GPIO_ADXL_INT)); // << Crashes here
338:                unfreeze_gpio_out();
339:                unfreeze_spi_out();
287:            *REG_CPS = *REG_CPS | 0x2;      // Turn on ADXL
291:            ADXL362_init();
251:                ADXL362_reg_wr(ADXL362_SOFT_RESET,0x52);
227:                    gpio_write_data_with_mask(adxl_mask,(0<<GPIO_ADXL_EN) | (0<<GPIO_ADXL_INT));
233:                    gpio_write_data_with_mask(adxl_mask,(1<<GPIO_ADXL_EN) | (0<<GPIO_ADXL_INT));
275:                ADXL362_reg_rd(ADXL362_STATUS);
238:                    gpio_write_data_with_mask(adxl_mask,(0<<GPIO_ADXL_EN) | (0<<GPIO_ADXL_INT));
244:                    gpio_write_data_with_mask(adxl_mask,(1<<GPIO_ADXL_EN) | (0<<GPIO_ADXL_INT));
294             operation_spi_stop();
343:                freeze_spi_out();
344:                freeze_gpio_out();
1688:       gpio_write_data_with_mask(sht35_mask,(1<<GPIO_SDA) | (1<<GPIO_SCL));
1696        operation_spi_init();
336:            gpio_set_dir_with_mask(adxl_mask,(1<<GPIO_ADXL_EN) | (0<<GPIO_ADXL_INT));
337:            gpio_write_data_with_mask(adxl_mask,(1<<GPIO_ADXL_EN) | (0<<GPIO_ADXL_INT)); // << Crashes here
338:            unfreeze_gpio_out();
339:            unfreeze_spi_out();
1697        ADXL362_reg_rd(ADXL362_STATUS);
238:            gpio_write_data_with_mask(adxl_mask,(0<<GPIO_ADXL_EN) | (0<<GPIO_ADXL_INT));
244:            gpio_write_data_with_mask(adxl_mask,(1<<GPIO_ADXL_EN) | (0<<GPIO_ADXL_INT));
1701        operation_spi_stop();
343:             freeze_spi_out();
344:             freeze_gpio_out();
1717:       operation_sleep_notimer();
1253:           ADXL362_power_off();
323:                ADXL362_stop();
301:                    operation_spi_init();
336:                        gpio_set_dir_with_mask(adxl_mask,(1<<GPIO_ADXL_EN) | (0<<GPIO_ADXL_INT));
337:                        gpio_write_data_with_mask(adxl_mask,(1<<GPIO_ADXL_EN) | (0<<GPIO_ADXL_INT)); // << Crashes here
338:                        unfreeze_gpio_out();
339:                        unfreeze_spi_out();
310:                    operation_spi_stop();
343:                        freeze_spi_out();
344:                        freeze_gpio_out();
314:                    unfreeze_gpio_out();            // ????
316:                    gpio_set_dir_with_mask(adxl_mask,(1<<GPIO_ADXL_EN) | (1<<GPIO_ADXL_INT));
317:                    gpio_write_data_with_mask(adxl_mask,0);
318:                    freeze_gpio_out();
325:                *REG_CPS = *REG_CPS & 0xFFFFFFFD;   // Turn off ADXL
1256:           operation_sns_sleep_check();    
1265:       operation_sleep();
1234:           mbus_sleep_all();
2940    operation_sns_run(); (?)
2044    operation_sleep_notimer();


< STOP >
1976:}else if(wakeup_data_header == 0x33){

1982:   operation_sns_sleep_check();
1989:   ADXL362_power_off();
1993:   radio_power_on();
1995:   operation_goc_trigger_radio(wakeup_data_field_0, wakeup_data_field_1, 0xC1, exec_count_irq, exec_count); 



0xA0005000 => 0x02
0x1F0 => 0x4B034318
0x1F4 => 0x681B6018
0x200 => 0x00001884
0x1F8 => 0x47706013
0x1884 <= 0x12
0x1884 => 0x12
0x1FC => 0xA0005000
0xA0005000 <= 0x12
