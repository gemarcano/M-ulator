//*******************************************************************************************
// XT1 (TMCv1) FIRMWARE
// Version alpha-0.1
//-------------------------------------------------------------------------------------------
// TMCv1 SUB-LAYER CONNECTION:
//      PREv22E -> SNTv5 -> EIDv1 -> MRRv11A -> MEMv3 -> PMUv13
//-------------------------------------------------------------------------------------------
// Major portion of this code is based on TSstack_ondemand_v2.0 (pre_v20e)
//-------------------------------------------------------------------------------------------
// < UPDATE HISTORY >
//  Jun 24 2021 -   First commit 
//-------------------------------------------------------------------------------------------
// < AUTHOR > 
//  Yejoong Kim (yejoong@cubeworks.io)
//******************************************************************************************* 

// FIXME: Use GOC to once write the current time, then the program could keep track of the current time using XO timer?

#include "TMCv1.h"

#define PRE_ADDR    0x1
#define SNT_ADDR    0x2
#define EID_ADDR    0x3
#define MRR_ADDR    0x4
#define MEM_ADDR    0x5
#define PMU_ADDR    0x6

// Debugging
#define ARB_DEBUG   // Send out ARB Debug Messages. Only for verilog simulations.

// Flag Idx
#define FLAG_INITIALIZED    0
#define FLAG_GIT_ENABLED    1
#define FLAG_GIT_TRIGGERD   2

// Target Register Index for Layer communications.
// A register write message from a certain layer will be written 
// in the following register in PRE.
// NOTE: Reg0x0-0x3 are retentive; Reg0x4-0x7 are non-retentive.
#define PMU_TARGET_REG_IDX  0x0
#define SNT_TARGET_REG_IDX  0x1
#define EID_TARGET_REG_IDX  0x2
#define MRR_TARGET_REG_IDX  0x3

#define PMU_TARGET_REG_ADDR  ((volatile uint32_t *) (0xA0000000 | (PMU_TARGET_REG_IDX << 2)))
#define SNT_TARGET_REG_ADDR  ((volatile uint32_t *) (0xA0000000 | (SNT_TARGET_REG_IDX << 2)))
#define EID_TARGET_REG_ADDR  ((volatile uint32_t *) (0xA0000000 | (EID_TARGET_REG_IDX << 2)))
#define MRR_TARGET_REG_ADDR  ((volatile uint32_t *) (0xA0000000 | (MRR_TARGET_REG_IDX << 2)))

// System State
#define STATE_A     0x1010
#define STATE_B     0x1011

// XO Counter Value per Specific Time Durations
#define XOT_1SEC    32765
#define XOT_1MIN    60*XOT_1SEC
#define XOT_1HR     60*XOT_1MIN
#define XOT_1DAY    24*XOT_1HR

// Sleep Duration (NOTE: These values are intentionaly set to a small value for verilog simulation)
#define SLEEP_DURATION_LONG     XOT_1SEC    // The long sleep duration during which the user must put on a GIT sticker
#define SLEEP_DURATION_PRE_GIT  XOT_1SEC    // The sleep duration before activating the system
#define SLEEP_DURATION          XOT_1SEC    // The sleep duration after the system activation

// Counter Thresholds (Default CPU Clock Frequency: ~100kHz)
#define TIMER32_VAL 300000

// System Operation Mode
#define ACTIVE 0x1
#define SLEEP  0x0

// PMU Temperatures
#define PMU_0C 0x0
#define PMU_10C 0x1
#define PMU_15C 0x2
#define PMU_20C 0x3
#define PMU_25C 0x4
#define PMU_30C 0x5
#define PMU_35C 0x6
#define PMU_40C 0x7
#define PMU_45C 0x8
#define PMU_55C 0x9
#define PMU_65C 0xA
#define PMU_75C 0xB
#define PMU_85C 0xC
#define PMU_95C 0xD

// PMU Behavior
#define PMU_CHECK_WRITE         // If enabled, PMU replies with an actual read-out data from the analog block, rather than just forwarding the write data.
#define DO_SAR_RESET            // Perform sar_reset followed by sar/upc/dnc_stabilized, after changing SAR ratio
#define PMU_ADC_PERIOD      1   // Period of ADC VBAT measurement (Default: 500)
#define PMU_TICK_ADC_RESET  2   // Pulse Width of PMU's ADC_RESET signal (Default: 50)
#define PMU_TICK_ADC_CLK    2   // Pulse Width of PMU's ADC_CLK signal (Default: 2)

// PMU VSOLAR SHORT BEHAVIOR    // FIXME: Ask about bit[11] - "Set VBAT_HIGH_LATRST"
// --------------------------------------
// PMU_VSOLAR_SHORT    | EN_VSOLAR_SHORT
// Value               | Behavior
// --------------------------------------
//   0x08 (default)    | 0 until POR activates; then 1 until V0P6 output turns on; then follows vbat_high_latched.
//   0x0A              | Always 0
//   0x0B              | Always 1
//   0x0C              | vbat_high_latched     (comparator output from PMU)
//   0x18              | vbat_high_lat_latched (latched comparator output from PMU)
// --------------------------------------
#define PMU_VSOLAR_SHORT        0x08    // (Default 5'h08) See table above
#define PMU_VSOLAR_CLAMP_TOP    0x0     // (Default 3'h0) Decrease clamp threshold voltage
#define PMU_VSOLAR_CLAMP_BOTTOM 0x1     // (Default 3'h1) Increase clamp threshold voltage

// Failure Codes
#define FCODE_0     1   // Unexpected State value in Pre-GIT / Wakeup Timer / Wakeup IRQ
#define FCODE_1     2   // Unexpected State value in Post-GIT / Wakeup Timer / Wakeup IRQ
#define FCODE_2     2   // Unexpected State value in Pre-GIT / MBus / Wakeup IRQ
#define FCODE_3     3   // Unexpected State value in Post-GIT / MBus / Wakeup IRQ
#define FCODE_4     4   // Timeout during PMU Register Write
#define FCODE_5     5   // Timeout during PMU Register Read
#define FAIL_MBUS_ADDR  0xE0    // In case of failure, it sends an MBus message containing the failure code to this MBus Address.

//********************************************************************
// Global Variables
//********************************************************************

volatile uint32_t state;
volatile uint32_t wfi_timeout_flag;
volatile uint32_t exec_count;
volatile uint32_t wakeup_count;
volatile uint32_t exec_count_irq;
volatile uint32_t PMU_ADC_3P0_VAL;
volatile uint32_t pmu_setting_state;
volatile uint32_t pmu_parking_mode;
volatile uint32_t snt_running;

volatile pre_r0B_t pre_r0B = PRE_R0B_DEFAULT;
volatile snt_r00_t snt_r00 = SNT_R00_DEFAULT;
volatile snt_r01_t snt_r01 = SNT_R01_DEFAULT;
volatile snt_r03_t snt_r03 = SNT_R03_DEFAULT;

//-------------------------------------------------------------------
// PMU State
//-------------------------------------------------------------------
//                                  Default Value
// idx  state_name                  sleep   active
//-------------------------------------------------------------------
// [20] horizon                     1       0
// [19] vbat_read_only              0       0
// [18] vdd_0p6_turned_on           1       1
// [17] vdd_1p2_turned_on           1       1
// [16] vdd_3p6_turned_on           1       1
// [15] dnc_stabilized              1       1
// [14] dnc_on                      1       1
// [13] sar_ratio_adjusted          1       0
// [12] adc_adjusted                1       0
// [11] adc_output_ready            1       1
// [10] refgen_on                   1       1
// [9]  upc_stabilized              1       1
// [8]  upc_on                      1       1
// [7]  control_supply_switched     1       1
// [6]  clock_supply_switched       1       1
// [5]  sar_ratio_roughly_adjusted  1       1
// [4]  sar_stabilized              1       1
// [3]  sar_reset                   1       1
// [2]  wait_for_cap_charge         1       1
// [1]  wait_for_clock_cycles       1       1
// [0]  sar_on                      1       1
//-------------------------------------------------------------------
volatile union pmu_state pmu_desired_state_sleep;   // Register 0x3B
volatile union pmu_state pmu_desired_state_active;  // Register 0x3C
volatile union pmu_state pmu_stall_state_sleep;     // Register 0x39
volatile union pmu_state pmu_stall_state_active;    // Register 0x3A


//-------------------------------------------------------------------
// PMU Floor Loop-Up Tables
//-------------------------------------------------------------------

// ACTIVE
volatile union pmu_floor pmu_floor_active[] = {
    //  Temp       idx     R    L    BASE  L_SAR
    /*PMU_0C  */ /* 0*/  {{0xF, 0xA, 0x1F, 0xE}},
    /*PMU_10C */ /* 1*/  {{0xF, 0xA, 0x10, 0xE}},
    /*PMU_15C */ /* 2*/  {{0xE, 0xA, 0x10, 0xE}},
    /*PMU_20C */ /* 3*/  {{0xD, 0xA, 0x10, 0xE}},
    /*PMU_25C */ /* 4*/  {{0xF, 0x5, 0x10, 0xA}},
    /*PMU_30C */ /* 5*/  {{0xF, 0x3, 0x10, 0x5}},
    /*PMU_35C */ /* 6*/  {{0xD, 0x2, 0x10, 0x4}},
    /*PMU_40C */ /* 7*/  {{0xB, 0x2, 0x10, 0x4}},
    /*PMU_45C */ /* 8*/  {{0x9, 0x2, 0x10, 0x4}},
    /*PMU_55C */ /* 9*/  {{0x6, 0x2, 0x10, 0x4}},
    /*PMU_65C */ /*10*/  {{0x4, 0x2, 0x10, 0x4}},
    /*PMU_75C */ /*11*/  {{0x2, 0x2, 0x10, 0x4}},
    /*PMU_85C */ /*12*/  {{0x2, 0x1, 0x10, 0x2}},
    /*PMU_95C~*/ /*13*/  {{0x1, 0x1, 0x10, 0x2}},
    };

// SLEEP
volatile union pmu_floor pmu_floor_sleep[] = {
    //  Temp Range        idx     R    L    BASE  L_SAR
    /*       ~PMU_0C */ /* 0*/  {{0xF, 0x2, 0x01, 0x4}},
    /*PMU_10C~PMU_15C*/ /* 1*/  {{0xF, 0x1, 0x01, 0x2}},
    /*PMU_20C~PMU_45C*/ /* 2*/  {{0xF, 0x0, 0x01, 0x1}},
    /*PMU_55C~PMU_65C*/ /* 3*/  {{0x6, 0x0, 0x01, 0x1}},
    /*PMU_75C~PMU_85C*/ /* 4*/  {{0x4, 0x0, 0x01, 0x1}},
    /*PMU_95C~       */ /* 5*/  {{0x2, 0x0, 0x01, 0x1}},
    };

// SLEEP (TEMP SENSOR)
volatile union pmu_floor pmu_floor_sleep_tsnt[] = {
    //  Temp Range        idx     R    L    BASE  L_SAR
    /*PMU_0C ~PMU_15C*/ /* 0*/  {{0xF, 0xA, 0x07, 0xF}},
    /*PMU_20C~PMU_30C*/ /* 1*/  {{0xF, 0xA, 0x05, 0xF}},
    /*PMU_35C~PMU_65C*/ /* 2*/  {{0xA, 0xA, 0x05, 0xF}},
    /*PMU_75C~       */ /* 3*/  {{0x5, 0xA, 0x05, 0xF}},
    };

// SLEEP (LOW)
volatile union pmu_floor pmu_floor_sleep_low[] = {
    //  idx     R    L    BASE  L_SAR
      /* 0*/  {{0xF, 0xA, 0x07, 0xF}},
      }

// SLEEP (RADIO)
volatile union pmu_floor pmu_floor_sleep_radio[] = {
    //  idx     R    L    BASE  L_SAR
      /* 0*/  {{0xF, 0xA, 0x05, 0xF}},
      }

//-------------------------------------------------------------------
// Temperature Sensor Threshold for PMU Floor Setting
//-------------------------------------------------------------------
volatile uint32_t PMU_10C_threshold_snt = 600; // Around 10C
volatile uint32_t PMU_15C_threshold_snt = 800; 
volatile uint32_t PMU_20C_threshold_snt = 1000; // Around 20C
volatile uint32_t PMU_25C_threshold_snt = 1300; // Around 20C
volatile uint32_t PMU_30C_threshold_snt = 1600; 
volatile uint32_t PMU_35C_threshold_snt = 1900; // Around 35C
volatile uint32_t PMU_40C_threshold_snt = 2200;
volatile uint32_t PMU_45C_threshold_snt = 2500;
volatile uint32_t PMU_55C_threshold_snt = 3200; // Around 55C
volatile uint32_t PMU_65C_threshold_snt = 4500; 
volatile uint32_t PMU_75C_threshold_snt = 7000; // Around 75C
volatile uint32_t PMU_85C_threshold_snt = 9400; 
volatile uint32_t PMU_95C_threshold_snt = 12000; // Around 95C

//-------------------------------------------------------------------
// Temperature Sensor Calibration Coefficients
//-------------------------------------------------------------------
// TEMP_CALIB_A: A is the slope, typical value is around 24.000, stored as A*1000
// TEMP_CALIB_B: B is the offset, typical value is around -3750.000, stored as -(B-3400)*100 due to limitations on radio bitfield
//-------------------------------------------------------------------
volatile uint32_t TEMP_CALIB_A = 24000; 
volatile uint32_t TEMP_CALIB_B = 20000; 

//*******************************************************************
// FUNCTIONS DECLARATIONS
//*******************************************************************

static uint32_t set_bits (uint32_t original_var, uint32_t msb_idx, uint32_t lsb_idx, uint32_t value);
static uint32_t get_bits (uint32_t variable, uint32_t msb_idx, uint32_t lsb_idx);
static uint32_t get_bit (uint32_t variable, uint32_t idx);

//-- PRE Functions
static void set_timer32_timeout(uint32_t val);
static void stop_timer32_timeout_check(uint32_t code);
static void set_xo_wakeup_timer(uint32_t timestamp);
static void disable_xo_wakeup_req(void);
static void xo_start(void);
static void xo_stop(void);

//-- PMU Functions
static void pmu_reg_write_core (uint32_t reg_addr, uint32_t reg_data, uint32_t fail_code);
static void pmu_reg_write (uint32_t reg_addr, uint32_t reg_data);
static uint32_t pmu_reg_read (uint32_t reg_addr);
static void pmu_set_floor(uint8_t mode, uint8_t r, uint8_t l, uint8_t base, uint8_t l_sar);
static void pmu_set_active_temp_based();
static void pmu_set_sleep_temp_based();
static void pmu_set_sleep_low();
static void pmu_set_sleep_radio();
static void pmu_set_sleep_tsnt();
static void pmu_set_sar_ratio (uint32_t ratio);
static void pmu_set_adc_period(uint32_t val);
static void pmu_init();

//-- SNT Functions
static void snt_temp_sensor_power_off(void);
static void snt_ldo_power_off(void);

//-- Operation Init/Sleep Functions
static void operation_sleep (void);
static void operation_prepare_sleep_notimer(void);
static void operation_sleep_notimer(void);
static void operation_sleep_xo_timer(uint32_t timestamp);
static void operation_init (void);

//-- Application Specific
static void post_git_initialization(void);
static void pregit_do_state_a (void);
static void pregit_do_state_b (void);
static void pregit_do_state_a (void);
static void pregit_do_state_b (void);
static void do_nfc(void);
static void fail (uint32_t code);

//*******************************************************************
// BASIC BUILDING FUNCTIONS
//*******************************************************************

//-------------------------------------------------------------------
// Function: set_bits
// Args    : original_var - Original Value
//           msb_idx      - Index of MSB
//           lsb_idx      - Index of LSB
//           value        - New value
// Description:
//          set_bits() replaces [msb_idx:lsb_idx] in original_var with value
//          and returns the result
// Return  : original_var with [msb_idx:lsb_idx] replaced with value
//-------------------------------------------------------------------
static uint32_t set_bits (uint32_t original_var, uint32_t msb_idx, uint32_t lsb_idx, uint32_t value) {
    uint32_t mask_pattern = (0xFFFFFFFF << (msb_idx + 1)) | (0xFFFFFFFF >> (32 - lsb_idx));
    return (original_var & mask_pattern) | ((value << lsb_idx) & ~mask_pattern);
}

//-------------------------------------------------------------------
// Function: get_bits
// Args    : variable   - Original Value
//           msb_idx    - Index of MSB
//           lsb_idx    - Index of LSB
// Description:
//          get_bits() grabs [msb_idx:lsb_idx] in variable,
//          right-shifts it by lsb_idx and returns the result.
// Return  : [msb_idx:lsb_idx] in variable right-shifted by lsb_idx
//-------------------------------------------------------------------
static uint32_t get_bits (uint32_t variable, uint32_t msb_idx, uint32_t lsb_idx) {
    return ((variable << (31-msb_idx)) >> (31-msb_idx)) >> lsb_idx;
}

//-------------------------------------------------------------------
// Function: get_bit
// Args    : variable - Original Value
//           idx      - Bit Index
// Description:
//          get_bit() returns variable[idx]
// Return  : variable[idx] (it is always 1 bit)
//-------------------------------------------------------------------
static uint32_t get_bit (uint32_t variable, uint32_t idx) {
    return get_bits(variable, idx, idx);
}

//*******************************************************************
// TIMER FUNCTIONS
//*******************************************************************

//-------------------------------------------------------------------
// Function: set_timer32_timeout
// Args    : var - Threshold
// Description:
//          set_timer32_timeout() initializes and starts the TIMER 32
//          for a time-out check
// Return  : None
//-------------------------------------------------------------------
static void set_timer32_timeout(uint32_t val){
    wfi_timeout_flag = 0;
    config_timer32(/*cmp*/val, /*roi*/1, /*cnt*/0, /*status*/0);
}

//-------------------------------------------------------------------
// Function: stop_timer32_timeout_check
// Args    : code - Error code
// Description:
//          stop_timer32_timeout_check() stops the TIMER32.
//          If there is a timeout, it calls fail().
// Return  : None
//-------------------------------------------------------------------
static void stop_timer32_timeout_check(uint32_t code){
    *TIMER32_GO = 0;
    if (wfi_timeout_flag){
        wfi_timeout_flag = 0;
        fail (code);
    }
}

//*******************************************************************
// PMU FUNCTIONS
//*******************************************************************

//-------------------------------------------------------------------
// Function: pmu_reg_write_core
// Args    : reg_addr  - Register Address
//           reg_data  - Register Data
//           fail_code - Fail Code for Time-Out
// Description:
//          pmu_reg_write_core() writes reg_data in PMU's reg_addr
//          It also performs a time-out check.
// Return  : None
//-------------------------------------------------------------------
static void pmu_reg_write_core (uint32_t reg_addr, uint32_t reg_data, uint32_t fail_code) {
    set_timer32_timeout(TIMER32_VAL);
    mbus_remote_register_write(PMU_ADDR,reg_addr,reg_data);
    WFI();
    stop_timer32_timeout_check(fail_code);
}

//-------------------------------------------------------------------
// Function: pmu_reg_write
// Args    : reg_addr - Register Address
//           reg_data - Register Data
// Description:
//          pmu_reg_write() writes reg_data in PMU's reg_addr
//          It also performs a time-out check.
// Return  : None
//-------------------------------------------------------------------
static void pmu_reg_write (uint32_t reg_addr, uint32_t reg_data) {
    pmu_reg_write_core(reg_addr, reg_data, FCODE_4);
}

//-------------------------------------------------------------------
// Function: pmu_reg_read
// Args    : reg_addr
// Description:
//          pmu_reg_read() read from reg_addr in PMU.
//          It also performs a time-out check.
// Return  : Read Data
//-------------------------------------------------------------------
static uint32_t pmu_reg_read (uint32_t reg_addr) {
    pmu_reg_write_core(0x00, reg_addr, FCODE_5);
    return *PMU_TARGET_REG_ADDR;
}

//-------------------------------------------------------------------
// Function: pmu_init
// Args    : None
// Description:
//           Initializes the PMU's floor settings & SAR ratio
//              for the nominal condition.
//           It also disables PMU's ADC operation for Active mode
//              and sets ADC timing parameters.
// Return  : None
//-------------------------------------------------------------------
static void pmu_init(){

    #ifdef PMU_CHECK_WRITE // See PMU Behavior section at the top)
        //[5]: PMU_CHECK_WRITE(1'h0); [4]: PMU_IRQ_EN(1'h1); [3:2]: LC_CLK_DIV(2'h3); [1:0]: LC_CLK_RING(2'h1)
        mbus_remote_register_write(PMU_ADDR, 0x51, (0x1 << 5) | (0x1 << 4) | (0x3 << 2) | (0x1 << 0));
    #endif

    // Initialize PMU State Variables
    pmu_desired_state_sleep  = PMU_DESIRED_STATE_SLEEP_DEFAULT;
    pmu_desired_state_active = PMU_DESIRED_STATE_ACTIVE_DEFAULT;
    pmu_stall_state_sleep    = PMU_STALL_STATE_SLEEP_DEFAULT;
    pmu_stall_state_active   = PMU_STALL_STATE_ACTIVE_DEFAULT;

    // Initialized the temperature to 25C and adjust floors
    pmu_setting_state = PMU_25C;
    pmu_set_active_temp_based();
    pmu_set_sleep_temp_based();

    // Initialize SAR Ratio
    pmu_set_sar_ratio(0x45);

    // Disable ADC in Active
    // PMU ADC will be automatically reset when system wakes up
    //---------------------------------------------------
    // CTRL_DESIRED_STATE_ACTIVE
    //---------------------------------------------------
    pmu_desired_state_active.adc_output_ready   = 0;
    pmu_desired_state_active.adc_adjusted       = 0;
    pmu_desired_state_active.sar_ratio_adjusted = 0;
    pmu_desired_state_active.vbat_read_only     = 0;
    pmu_reg_write(0x3C, pmu_desired_state_active.value);

    // Turn off ADC offset measurement in Sleep
    //---------------------------------------------------
    // CTRL_DESIRED_STATE_SLEEP
    //---------------------------------------------------
    pmu_desired_state_sleep.adc_adjusted       = 0;
    pmu_desired_state_sleep.vbat_read_only     = 0;
    pmu_reg_write(0x3B, pmu_desired_state_sleep.value);

    // Set ADC Period
    pmu_set_adc_period(PMU_ADC_PERIOD);

    // Horizon Behavior // FIXME: We may need not this. [7:0] is only for 'vbat_read_only' which is not enabled at all.
    //---------------------------------------------------------------------------------------
    // HORIZON_CONFIG
    //---------------------------------------------------------------------------------------
    pmu_reg_write(0x45, // Default  // Description
    //---------------------------------------------------------------------------------------
        // NOTE: [14:11] is ignored if the corresponding DESIRED=0 -OR- STALL=1.
        //------------------------------------------------------------------------
        ( (0x1 << 14)   // 0x1      // If 1, 'horizon' enqueues 'wait_clock_count' with TICK_REPEAT_VBAT_ADJUST
        | (0x1 << 13)   // 0x1      // If 1, 'horizon' enqueues 'adjust_adc'
        | (0x1 << 12)   // 0x1      // If 1, 'horizon' enqueues 'adjust_sar_ratio'
        | (0x1 << 11)   // 0x1      // If 1, 'horizon' enqueues 'vbat_read_only'
        //------------------------------------------------------------------------
        | (0x0 << 9 )   // 0x0      // 0x0: Disable clock monitoring
                                    // 0x1: Monitoring SAR clock
                                    // 0x2: Monitoring UPC clock
                                    // 0x3: Monitoring DNC clock
        | (0x0  << 8)   // 0x0      // Reserved
        | (0x48 << 0)   // 0x48     // Sets ADC_SAMPLING_BIT in 'vbat_read_only' task
    ));

    // VOLTAGE_CLAMP_TRIM (See PMU VSOLAR SHORT BEHAVIOR section at the top)
    pmu_reg_write(0x0E, (PMU_VSOLAR_SHORT << 8) | (PMU_VSOLAR_CLAMP_BOTTOM << 4) | (PMU_VSOLAR_CLAMP_TOP << 0));

}

//-------------------------------------------------------------------
// Function: pmu_set_adc_period
// Args    : val - desired period for ADC VBAT measurement
// Description:
//           Sets ADC VBAT measurement to 'val'.
//           Also sets the pulse width of ADC_RESET and ADC_CLK.
// Return  : None
//-------------------------------------------------------------------
static void pmu_set_adc_period(uint32_t val){
    //---------------------------------------------------
    // TICK_REPEAT_VBAT_ADJUST
    //---------------------------------------------------
    pmu_reg_write(0x36, val); 

    //---------------------------------------------------
    // TICK_ADC_RESET
    //---------------------------------------------------
    pmu_reg_write(0x33, PMU_TICK_ADC_RESET);

    //---------------------------------------------------
    // TICK_ADC_CLK
    //---------------------------------------------------
    pmu_reg_write(0x34, PMU_TICK_ADC_CLK);
}

//-------------------------------------------------------------------
// Function: pmu_set_sar_ratio
// Args    : ratio - desired SAR ratio
// Description:
//           Overrides SAR ratio with 'ratio', and then performs
//           sar_reset and sar/upc/dnc_stabilized tasks
// Return  : None
//-------------------------------------------------------------------
static void pmu_set_sar_ratio (uint32_t ratio) {
    #ifdef DO_SAR_RESET
        uint32_t rst = 0x3;
    #else
        uint32_t rst = 0x0;
    #endif

    //---------------------------------------------------------------------------------------
    // SAR_RATIO_OVERRIDE
    //---------------------------------------------------------------------------------------
    pmu_reg_write(0x05, // Default  // Description
    //---------------------------------------------------------------------------------------
        ( (rst << 14)   // 0x0      // 0x3: Perform sar_reset followed by sar/upc/dnc_stabilized upon writing into this register
                                    // 0x2: Perform sar_reset upon writing into this register
                                    // 0x1: Perform sar/upc/dnc_stabilized upon writing into this register
                                    // 0x0: Do nothing
        | (0x2 << 12)   // 0x0      // 0x3: Let VDD_CLK always connected to VBAT; 
                                    // 0x2: Let VDD_CLK always connected to V1P2;
                                    // 0x0: Let PMU handle.
        | (0x2 << 10)   // 0x2      // 0x3: Enable the periodic SAR reset; 
                                    // 0x2: Disable the periodic SAR reset; 
                                    // 0x0: Let PMU handle.
                                    // This setting is temporarily ignored when [15] is triggered.
        | (0x0 << 8 )   // 0x0      // 0x3: Let the SAR do UP-conversion (use if VBAT < 1.2V)
                                    // 0x2: Let the SAR do DOWN-conversion (use if VBAT > 1.2V)
                                    // 0x0: Let PMU handle.
        | (0x1 << 7 )   // 0x0      // If 1, override SAR ratio with [6:0].
        | (ratio)       // 0x00     // SAR ratio for overriding (valid only when [7]=1)
    ));
}

//-------------------------------------------------------------------
// Function: pmu_set_active_temp_based
// Args    : None
// Description:
//           Sets PMU active floors based on temperature
// Return  : None
//-------------------------------------------------------------------
static void pmu_set_active_temp_based(){
    uint32_t index = pmu_setting_state;
    pmu_set_floor(ACTIVE, 
                    pmu_floor_active[index].R,
                    pmu_floor_active[index].L,
                    pmu_floor_active[index].BASE,
                    pmu_floor_active[index].L_SAR
                    );
}

//-------------------------------------------------------------------
// Function: pmu_set_sleep_temp_based
// Args    : None
// Description:
//           Sets PMU sleep floors based on temperature
// Return  : None
//-------------------------------------------------------------------
static void pmu_set_sleep_temp_based(){
    uint32_t index;
    if      (pmu_setting_state <= PMU_0C ) index = 0;
    else if (pmu_setting_state <= PMU_15C) index = 1;
    else if (pmu_setting_state <= PMU_45C) index = 2;
    else if (pmu_setting_state <= PMU_65C) index = 3;
    else if (pmu_setting_state <= PMU_85C) index = 4;
    else                                   index = 5;
    pmu_set_floor(SLEEP, 
                    pmu_floor_sleep[index].R,
                    pmu_floor_sleep[index].L,
                    pmu_floor_sleep[index].BASE,
                    pmu_floor_sleep[index].L_SAR
                    );
}

//-------------------------------------------------------------------
// Function: pmu_set_sleep_tsnt
// Args    : None
// Description:
//           Sets PMU sleep floors for Temp Sensor operation
// Return  : None
//-------------------------------------------------------------------
static void pmu_set_sleep_tsnt(){
    uint32_t index;
    if      (pmu_setting_state <= PMU_15C) index = 0;
    else if (pmu_setting_state <= PMU_30C) index = 1;
    else if (pmu_setting_state <= PMU_65C) index = 2;
    else                                   index = 3;
    pmu_set_floor(SLEEP, 
                    pmu_floor_sleep[index].R,
                    pmu_floor_sleep[index].L,
                    pmu_floor_sleep[index].BASE,
                    pmu_floor_sleep[index].L_SAR
                    );
}

//-------------------------------------------------------------------
// Function: pmu_set_sleep_low
// Args    : None
// Description:
//           Sets PMU sleep floors to its lowest setting
// Return  : None
//-------------------------------------------------------------------
static void pmu_set_sleep_low(){
    pmu_set_floor(SLEEP, 
                    pmu_floor_sleep_low[0].R,
                    pmu_floor_sleep_low[0].L,
                    pmu_floor_sleep_low[0].BASE,
                    pmu_floor_sleep_low[0].L_SAR
                    );
}

//-------------------------------------------------------------------
// Function: pmu_set_sleep_radio
// Args    : None
// Description:
//           Sets PMU sleep floors for Radio operation
// Return  : None
//-------------------------------------------------------------------
static void pmu_set_sleep_radio(){
    pmu_set_floor(SLEEP, 
                    pmu_floor_sleep_radio[0].R,
                    pmu_floor_sleep_radio[0].L,
                    pmu_floor_sleep_radio[0].BASE,
                    pmu_floor_sleep_radio[0].L_SAR
                    );
}

//-------------------------------------------------------------------
// Function: pmu_set_floor
// Args    : mode   - If 1, change settings for Active registers.
//                    If 0, change settings for Sleep registers.
//           r      - Right-Leg Multiplier
//           l      - Left-Leg Multiplier (for UPC & DNC)
//           base   - Base Value
//           l_sar  - Left-Leg Multiplier (for SAR)
// Description:
//           Set the VCO floor setting
// Return  : None
//-------------------------------------------------------------------
static void pmu_set_floor(uint8_t mode, uint8_t r, uint8_t l, uint8_t base, uint8_t l_sar){

    // Register Addresses
    uint32_t sar = (mode == ACTIVE) ? 0x16 : 0x15;
    uint32_t upc = (mode == ACTIVE) ? 0x18 : 0x17;
    uint32_t dnc = (mode == ACTIVE) ? 0x1A : 0x19;

    //---------------------------------------------------------------------------------------
    // SAR_TRIM_V3_[ACTIVE|SLEEP]
    //---------------------------------------------------------------------------------------
    pmu_reg_write(sar,  // Default  // Description
    //---------------------------------------------------------------------------------------
        ( (0 << 19)     // 1'h0     // Enable PFM even during periodic reset
        | (0 << 18)     // 1'h0     // Enable PFM even when VREF is not used as reference
        | (0 << 17)     // 1'h0     // Enable PFM
        | (3 << 14)     // 3'h3     // Comparator clock division ratio
        | (0 << 13)     // 1'h0     // Makes the converter clock 2x slower
        | (r << 9)      // 4'h8     // Frequency multiplier R
        | (l_sar << 5)  // 4'h8     // Frequency multiplier L (actually L+1)
        | (base)        // 5'h0F    // Floor frequency base (0-63)
    ));

    //---------------------------------------------------------------------------------------
    // UPC_TRIM_V3_[ACTIVE|SLEEP]
    //---------------------------------------------------------------------------------------
    pmu_reg_write(upc,  // Default  // Description
    //---------------------------------------------------------------------------------------
        ( (3 << 14)     // 2'h0     // Desired Vout/Vin ratio
        | (0 << 13)     // 1'h0     // Makes the converter clock 2x slower
        | (r << 9)      // 4'h8     // Frequency multiplier R
        | (l << 5)      // 4'h4     // Frequency multiplier L (actually L+1)
        | (base)        // 5'h08    // Floor frequency base (0-63)
    ));

    //---------------------------------------------------------------------------------------
    // DNC_TRIM_V3_[ACTIVE|SLEEP]
    //---------------------------------------------------------------------------------------
    pmu_reg_write(dnc,  // Default  // Description
    //---------------------------------------------------------------------------------------
        ( (0 << 13)     // 1'h0     // Makes the converter clock 2x slower
        | (r << 9)      // 4'h8     // Frequency multiplier R
        | (l << 5)      // 4'h4     // Frequency multiplier L (actually L+1)
        | (base)        // 5'h08    // Floor frequency base (0-63)
    ));
}

//*******************************************************************
// USER FUNCTIONS
//*******************************************************************

//-------------------------------------------------------------------
// Function: set_xo_wakeup_timer
// Args    : timestamp - Timestamp value at which the XO timer generates 
//                       a wakeup request
// Description:
//           Changes the XO Timer's threshold value using timestamp.
//           This function assumes that XO Driver and XO Timer have 
//           been already properly started.
// Return  : None
//-------------------------------------------------------------------
static void set_xo_wakeup_timer (uint32_t timestamp) {
    *REG_XOT_CONFIGU = (timestamp >> 16) & 0xFFFF;
    *REG_XOT_CONFIG  = (timestamp & 0x0000FFFF) | 0x00A00000; // [23] XOT_ENABLE = 1; [21] XOT_WREQ_EN = 1;
}

//-------------------------------------------------------------------
// Function: disable_xo_wakeup_req
// Args    : None
// Description:
//           Make XOT_WREQ_EN = 0, which prevents XO Wakeup Timer
//           from generating a wakeup request.
//           The XO Wakeup Timer running status is NOT affected 
//           by this function.
// Return  : None
//-------------------------------------------------------------------
static void disable_xo_wakeup_req (void) {
    *REG_XOT_CONFIG  = *REG_XOT_CONFIG & 0xFFDFFFFF; // [21] XOT_WREQ_EN = 0;
}

//-------------------------------------------------------------------
// Function: xo_start
// Args    : None
// Description:
//           Start the XO Driver and the XO Wakeup Timer
// Return  : None
//-------------------------------------------------------------------
static void xo_start( void ) {

    //--------------------------------------------------------------------------
    // XO Driver (XO_DRV_V3_TSMC180) Start-Up Sequence
    //--------------------------------------------------------------------------
    // RESETn       __|*********************************************************
    // PGb_StartUp  __|***************************|_____________________________
    // START_UP     **************************|_________________________________
    // ISOL_CLK_HP  **********|_________________|*******************************
    // ISOL_CLK_LP  ******************|_________________________________________
    //                |<--A-->|<--B-->|<--C-->|.|.|<-- Low Power Operation -->
    //--------------------------------------------------------------------------
    // A: ~1s  (XO Start-Up)
    // B: ~1s  (VLDO & IBIAS generation)
    // C: <1ms (SCN Output Generation)
    // .(dot): minimum delay
    //--------------------------------------------------------------------------

    pre_r19_t xo_control = PRE_R19_DEFAULT; // REG_XO_CONF1

    xo_control.XO_RESETn       = 1;
    xo_control.XO_PGb_START_UP = 1;
    *REG_XO_CONFIG1 = xo_control.as_int;

    delay(100000); // Delay A (~1s; XO Start-Up)

    xo_control.XO_ISOL_CLK_HP = 0;
    *REG_XO_CONFIG1 = xo_control.as_int;
    
    delay(100000); // Delay B (~1s; VLDO & IBIAS generation)

    xo_control.XO_ISOL_CLK_LP = 0;
    *REG_XO_CONFIG1 = xo_control.as_int;
    
    delay(100); // Delay C (~1ms; SCN Output Generation)

    xo_control.XO_START_UP = 0;
    *REG_XO_CONFIG1 = xo_control.as_int;
    
    xo_control.XO_ISOL_CLK_HP = 1;
    *REG_XO_CONFIG1 = xo_control.as_int;

    xo_control.XO_PGb_START_UP = 0;
    *REG_XO_CONFIG1 = xo_control.as_int;

    delay(100); // Dummy Delay

    // Start XO Wakeup Timer
    enable_xo_timer();
    start_xo_cnt();
}

//-------------------------------------------------------------------
// Function: xo_stop
// Args    : None
// Description:
//           Stop the XO Driver and the XO Wakeup Timer
// Return  : None
//-------------------------------------------------------------------
static void xo_stop( void ) {
    // Stop the XO Driver
    pre_r19_t xo_control = *REG_XO_CONF1;

    xo_control.XO_ISOL_CLK_LP = 1;
    *REG_XO_CONFIG1 = xo_control.as_int;

    xo_control.XO_RESETn   = 0;
    xo_control.XO_START_UP = 1;
    *REG_XO_CONFIG1 = xo_control.as_int;

    // Stop the XO Wakeup Timer
    disable_xo_timer();
}

//*******************************************************************
// SNT FUNCTIONS
//*******************************************************************


//-------------------------------------------------------------------
// Function: snt_temp_sensor_power_off
// Args    : None
// Description:
//           Turns off SNT Temp Sensor
// Return  : None
//-------------------------------------------------------------------
static void snt_temp_sensor_power_off(void){
    snt_r01.TSNS_RESETn         = 0;
    snt_r01.TSNS_SEL_LDO        = 0;
    snt_r01.TSNS_EN_SENSOR_LDO  = 0;
    snt_r01.TSNS_ISOLATE        = 1;
    mbus_remote_register_write(SNT_ADDR,0x01,snt_r01.as_int);
}

//-------------------------------------------------------------------
// Function: snt_ldo_power_off
// Args    : None
// Description:
//           Turns off SNT LDO
// Return  : None
//-------------------------------------------------------------------
static void snt_ldo_power_off(void){
    snt_r00.LDO_EN_VREF   = 0;
    snt_r00.LDO_EN_IREF   = 0;
    snt_r00.LDO_EN_LDO    = 0;
    mbus_remote_register_write(SNT_ADDR,0x00,snt_r00.as_int);
}

//*******************************************************************
// USER FUNCTIONS
//*******************************************************************

//-------------------------------------------------------------------
// Function: operation_sleep
// Args    : None
// Description:
//           Sends the MBus Sleep message
// Return  : None
//-------------------------------------------------------------------
static void operation_sleep (void) {
    *GOC_DATA_IRQ = 0;
    mbus_sleep_all();
    while(1);
}

//-------------------------------------------------------------------
// Function: operation_prepare_sleep_notimer
// Args    : None
// Description:
//           Turns off SNT Temp Sensor and LDO.
//           Set PMU to room temperature setting
// Return  : None
//-------------------------------------------------------------------
static void operation_prepare_sleep_notimer(void){
    // Disable Wakeup Request
    disable_xo_wakeup_request();
    // Make sure LDO is off
    if (snt_running){
        snt_running = 0;
        snt_temp_sensor_power_off();
        snt_ldo_power_off();
    }
    // Set PMU to room temp setting
    if (pmu_setting_state != PMU_25C){
        pmu_setting_state = PMU_25C;
        pmu_set_active_temp_based();
        pmu_set_sleep_temp_based();
    }
}

//-------------------------------------------------------------------
// Function: operation_sleep_notimer
// Args    : None
// Description:
//           Goes into sleep without a timer (i.e., indefinite sleep)
// Return  : None
//-------------------------------------------------------------------
static void operation_sleep_notimer(void){
    exec_count_irq = 0; // Make sure the irq counter is reset    
    operation_prepare_sleep_notimer();
    operation_sleep();
}

//-------------------------------------------------------------------
// Function: operation_sleep_xo_timer
// Args    : timestamp - Time stamp for the XO Timer
// Description:
//           Goes into sleep with XO Timer enabled
// Return  : None
//-------------------------------------------------------------------
static void operation_sleep_xo_timer(uint32_t timestamp){
    set_xo_wakeup_timer(timestamp);
    operation_sleep();
}

//-------------------------------------------------------------------
// Function: operation_init
// Args    : None
// Description:
//           Initializes the system
// Return  : None
//-------------------------------------------------------------------
static void operation_init (void) {

    // Set the flag
    set_flag(FLAG_INITIALIZED, 1);

    //-------------------------------------------------
    // PRE Tuning
    //-------------------------------------------------
    //--- Set CPU & MBus Clock Speeds      Default
    pre_r0B.CLK_GEN_RING         = 0x1; // 0x1
    pre_r0B.CLK_GEN_DIV_MBC      = 0x1; // 0x2
    pre_r0B.CLK_GEN_DIV_CORE     = 0x2; // 0x3
    pre_r0B.GOC_CLK_GEN_SEL_FREQ = 0x5; // 0x7
    pre_r0B.GOC_CLK_GEN_SEL_DIV  = 0x0; // 0x1
    pre_r0B.GOC_SEL              = 0xF; // 0x8
    *REG_CLKGEN_TUNE = prev21e_r0B.as_int;

    //-------------------------------------------------
    // Initialize Global Variables
    //-------------------------------------------------
    exec_count = 0;
    wakeup_count = 0;
    exec_count_irq = 0;
    PMU_ADC_3P0_VAL = 0x62;
    pmu_parking_mode = 3;
    snt_running = 0;

    //-------------------------------------------------
    // Enumeration
    //-------------------------------------------------
    set_halt_until_mbus_trx();
    mbus_enumerate(SNT_ADDR);
    mbus_enumerate(EID_ADDR);
    mbus_enumerate(MRR_ADDR);
    mbus_enumerate(MEM_ADDR);
    mbus_enumerate(PMU_ADDR);
    set_halt_until_mbus_tx();

    //-------------------------------------------------
    // Target Register Index
    //-------------------------------------------------
    mbus_remote_register_write(PMU_ADDR, 0x52, (0x10 << 8) | PMU_TARGET_REG_IDX);
    mbus_remote_register_write(SNT_ADDR, 0x07, (0x10 << 8) | SNT_TARGET_REG_IDX);
    mbus_remote_register_write(EID_ADDR, 0x05, (0x1 << 16) | (0x10 << 8) | EID_TARGET_REG_IDX);
    mbus_remote_register_write(MRR_ADDR, 0x1E, (0x10 << 8) | MRR_TARGET_REG_IDX); // FSM_IRQ_REPLY_PACKET
    mbus_remote_register_write(MRR_ADDR, 0x23, (0x10 << 8) | MRR_TARGET_REG_IDX); // TRX_IRQ_REPLY_PACKET

    //-------------------------------------------------
    // PMU Settings
    //-------------------------------------------------
    pmu_init();

    //-------------------------------------------------
    // SNT Settings
    //-------------------------------------------------

    // Temp Sensor Initialization
    snt_r01.TSNS_RESETn     = 0;
    snt_r01.TSNS_EN_IRQ     = 1;
    snt_r01.TSNS_BURST_MODE = 0;
    snt_r01.TSNS_CONT_MODE  = 0;
    mbus_remote_register_write(SNT_ADDR,0x01,snt_r01.as_int);

    // Set temp sensor conversion time
    snt_r03.TSNS_SEL_STB_TIME  = 0x1; // Default: 0x1
    snt_r03.TSNS_SEL_CONV_TIME = 0x6; // Default: 0x6
    mbus_remote_register_write(SNT_ADDR,0x03,snt_r03.as_int);

    //-------------------------------------------------
    // MRR Settings
    //-------------------------------------------------
    // NOTE: XT1 does not utilized MRR

    //-------------------------------------------------
    // EID Settings
    //-------------------------------------------------
    // FIXME

    // START FROM HERE!!!

    //-------------------------------------------------
    // XO Driver
    //-------------------------------------------------
    xo_start();

    //-------------------------------------------------
    // Sleep
    //-------------------------------------------------
    // It must go into sleep with a long 'sleep' duration
    // to give user enough time to put a "sticker" over the GOC solar cell.
    operation_sleep_xo_timer(SLEEP_DURATION_LONG);
}

// Post-GIT Initialization
static void post_git_initialization(void) {

}

// STATE A (Pre-GIT) Implementation
static void pregit_do_state_a (void) {
    // FIXME

    // Update the system state
    state = STATE_B;
}

// STATE B (Pre-GIT) Implementation
static void pregit_do_state_b (void) {
    // FIXME

    // Update the system state
    state = STATE_A;
}

// STATE A Implementation
static void pregit_do_state_a (void) {
    // FIXME

    // Update the system state
    state = STATE_B;
}

// STATE B Implementation
static void pregit_do_state_b (void) {
    // FIXME

    // Update the system state
    state = STATE_A;
}

// NFC Event handling
static void do_nfc(void) {

}

// FAIL: Unexpected Behavior
static void fail (uint32_t code) {
    mbus_write_message32(FAIL_MBUS_ADDR, code);
}


//*******************************************************************
// INTERRUPT HANDLERS
//*******************************************************************
void handler_ext_int_wakeup   (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_softreset(void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_gocep    (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_timer32  (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_timer16  (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_mbustx   (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_mbusrx   (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_mbusfwd  (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_reg0     (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_reg1     (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_reg2     (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_reg3     (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_reg4     (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_reg5     (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_reg6     (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_reg7     (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_mbusmem  (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_aes      (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_gpio     (void) __attribute__ ((interrupt ("IRQ")));
void handler_ext_int_spi      (void) __attribute__ ((interrupt ("IRQ")));

void handler_ext_int_timer32(void) { // TIMER32
    *NVIC_ICPR = (0x1 << IRQ_TIMER32);
    #ifdef
    arb_debug_reg(IRQ_TIMER32, 0x00000000);
    #endif
    *REG1 = *TIMER32_CNT;
    *REG2 = *TIMER32_STAT;
    *TIMER32_STAT = 0x0;
    wfi_timeout_flag = 1;
    set_halt_until_mbus_tx();
    }
void handler_ext_int_timer16(void) { // TIMER16
    *NVIC_ICPR = (0x1 << IRQ_TIMER16);
    #ifdef
    arb_debug_reg(IRQ_TIMER16, 0x00000000);
    #endif
    }
void handler_ext_int_reg0(void) { // REG0
    *NVIC_ICPR = (0x1 << IRQ_REG0);
    #ifdef
    arb_debug_reg(IRQ_REG0, 0x00000000);
    #endif
}
void handler_ext_int_reg1(void) { // REG1
    *NVIC_ICPR = (0x1 << IRQ_REG1);
    #ifdef
    arb_debug_reg(IRQ_REG1, 0x00000000);
    #endif
}
void handler_ext_int_reg2(void) { // REG2
    *NVIC_ICPR = (0x1 << IRQ_REG2);
    #ifdef
    arb_debug_reg(IRQ_REG2, 0x00000000);
    #endif
}
void handler_ext_int_reg3(void) { // REG3
    *NVIC_ICPR = (0x1 << IRQ_REG3);
    #ifdef
    arb_debug_reg(IRQ_REG3, 0x00000000);
    #endif
}
void handler_ext_int_reg4(void) { // REG4
    *NVIC_ICPR = (0x1 << IRQ_REG4);
    #ifdef
    arb_debug_reg(IRQ_REG4, 0x00000000);
    #endif
}
void handler_ext_int_reg5(void) { // REG5
    *NVIC_ICPR = (0x1 << IRQ_REG5);
    #ifdef
    arb_debug_reg(IRQ_REG5, 0x00000000);
    #endif
}
void handler_ext_int_reg6(void) { // REG6
    *NVIC_ICPR = (0x1 << IRQ_REG6);
    #ifdef
    arb_debug_reg(IRQ_REG6, 0x00000000);
    #endif
}
void handler_ext_int_reg7(void) { // REG7
    *NVIC_ICPR = (0x1 << IRQ_REG7);
    #ifdef
    arb_debug_reg(IRQ_REG7, 0x00000000);
    #endif
}
void handler_ext_int_mbusmem(void) { // MBUS_MEM_WR
    *NVIC_ICPR = (0x1 << IRQ_MBUS_MEM);
    #ifdef
    arb_debug_reg(IRQ_MBUS_MEM, 0x00000000);
    #endif
}
void handler_ext_int_mbusrx(void) { // MBUS_RX
    *NVIC_ICPR = (0x1 << IRQ_MBUS_RX);
    #ifdef
    arb_debug_reg(IRQ_MBUS_RX, 0x00000000);
    #endif
}
void handler_ext_int_mbustx(void) { // MBUS_TX
    *NVIC_ICPR = (0x1 << IRQ_MBUS_TX);
    #ifdef
    arb_debug_reg(IRQ_MBUS_TX, 0x00000000);
    #endif
}
void handler_ext_int_mbusfwd(void) { // MBUS_FWD
    *NVIC_ICPR = (0x1 << IRQ_MBUS_FWD);
    #ifdef
    arb_debug_reg(IRQ_MBUS_FWD, 0x00000000);
    #endif
}
void handler_ext_int_gocep(void) { // GOCEP
    *NVIC_ICPR = (0x1 << IRQ_GOCEP);
    #ifdef
    arb_debug_reg(IRQ_GOCEP, 0x00000000);
    #endif
    // FIXME: Any code to handle general tasks?
}
void handler_ext_int_softreset(void) { // SOFT_RESET
    *NVIC_ICPR = (0x1 << IRQ_SOFT_RESET);
    #ifdef
    arb_debug_reg(IRQ_SOFT_RESET, 0x00000000);
    #endif
}
void handler_ext_int_wakeup(void) { // WAKE-UP
    *NVIC_ICPR = (0x1 << IRQ_WAKEUP);
    uint32_t wakeup_source = *SREG_WAKEUP_SOURCE;
    *SCTR_REG_CLR_WUP_SOURCE = 1; // reset WAKEUP_SOURCE register
    #ifdef
    arb_debug_reg(IRQ_WAKEUP, (0x10 << 24) | wakeup_source);
    #endif

    // For safety, disable Wakeup Timer's WREQ.
    disable_xo_wakeup_req();

    //--------------------------------------------------------------------------
    // WAKEUP_SOURCE (wakeup_source) definition
    //--------------------------------------------------------------------------
    //  [31:12] - Reserved
    //     [11] - GPIO_PAD[3] has triggered wakeup (valid only when wakeup_source[3]=1)
    //     [10] - GPIO_PAD[2] has triggered wakeup (valid only when wakeup_source[3]=1)
    //     [ 9] - GPIO_PAD[1] has triggered wakeup (valid only when wakeup_source[3]=1)
    //     [ 8] - GPIO_PAD[0] has triggered wakeup (valid only when wakeup_source[3]=1)
    //  [ 7: 6] - Reserved
    //      [5] - GIT (GOC Instant Trigger) has triggered wakeup
    //      [4] - MBus message has triggered wakeup (e.g., Flash Auto Boot-up)
    //      [3] - One of GPIO_PAD[3:0] has triggered wakeup
    //      [2] - XO Timer has triggered wakeup
    //      [1] - Wake-up Timer has triggered wakeup
    //      [0] - GOC/EP has triggered wakeup
    //--------------------------------------------------------------------------

    // If woken up by GIT
    if (get_bit(wakeup_source, 5)) {
        set_flag(FLAG_GIT_TRIGGERED, 1);
        // Initialize the system state
        state = STATE_A;
        // Post-GIT Initialization
        post_git_initialization();
        // Start the normal sequence
        do_state_a();
    }
    // If woken up by a XO wakeup timer
    else if (get_bit(wakeup_source, 2)) {

        // If GIT is not yet enabled (i.e., the very first wakeup by the wakeup timer)
        if (!get_flag(FLAG_GIT_ENABLED)) {
            // Enable GIT (GOC Instant Trigger)
            *REG_GOC_CONFIG = set_bits(*REG_GOC_CONFIG, 16, 16, 1);
            set_flag(FLAG_GIT_ENABLED, 1);
            // Initialized the system state
            state = STATE_A;
        }

        // Before User Started the system
        if (!get_flag(FLAG_GIT_TRIGGERED)) { 
            if (state == STATE_A) pregit_do_state_a();
            else fail(FCODE_0);
        }
        // After User Started the system
        else {
            if (state == STATE_A) do_state_a();
            else fail(FCODE_1);
        }
    }
    // If woken up by NFC (GPIO[0])
    else if (get_bit(wakeup_source, 3) && get_bit(wakeup_source, 8)) {
        // Initialize the system state
        state = STATE_A;
        // Handle the NFC event
        do_nfc();
    }
    // If woken up by an SNT Temperature Sensor (FIXME: May want to add some signature check to tell whether the wakeup is due to a glitch on the wire)
    else if (get_bit(wakeup_source, 4)) {
        // Before User Started the system
        if (!get_flag(FLAG_GIT_TRIGGERED)) { 
            if (state == STATE_B) pregit_do_state_b();
            else fail(FCODE_2);
        }
        // After User Started the system
        else {
            if (state == STATE_B) do_state_b();
            else fail(FCODE_3);
        }
    }

    // NOTE: If the wakeup source is GOC/EP (i.e., wakeup_source[0] == 1)
    //       it will be handled by handler_ext_int_gocep()

}
void handler_ext_int_aes(void) { // AES
    *NVIC_ICPR = (0x1 << IRQ_AES);
    #ifdef
    arb_debug_reg(IRQ_SPI, 0x00000000);
    #endif
}
void handler_ext_int_spi(void) { // SPI
    *NVIC_ICPR = (0x1 << IRQ_SPI);
    #ifdef
    arb_debug_reg(IRQ_SPI, 0x00000000);
    #endif
}
void handler_ext_int_gpio(void) { // GPIO
    *NVIC_ICPR = (0x1 << IRQ_GPIO);
    #ifdef
    arb_debug_reg(IRQ_GPIO, 0x00000000);
    #endif
}

//********************************************************************
// MAIN function starts here             
//********************************************************************

int main() {
    // Enable IRQs
    *NVIC_ISER = (0x1 << IRQ_WAKEUP) | (0x1 << IRQ_GOCEP) | (0x1 << IRQ_TIMER32) 
               | (0x1 << IRQ_REG0  ) | (0x1 << IRQ_REG1 ) 
               | (0x1 << IRQ_REG2  ) | (0x1 << IRQ_REG3 );

    // Initialization Sequence
    if (!get_flag(FLAG_INITIALIZED)) { 
        operation_init();
    }

    // Never Quit (should not stay here for an extended duration)
    while(1) asm("nop");
    return 1;

//    // Sleep/Wakeup OR Terminate operation
//    if (cyc_num == 999) *REG_CHIP_ID = 0xFFFFFF; // This will stop the verilog sim.
//    else {
//        cyc_num++;
//        set_wakeup_timer(5, 1, 1);
//        mbus_sleep_all();
//    }

    *REG_CHIP_ID = 0xFFFFFF; // This will stop the verilog sim

    // Never Quit (should not come here)
    while(1) asm("nop;"); 
    return 1;
}
